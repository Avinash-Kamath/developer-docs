---
title: "Manage user sessions"
description: "Learn how to manage user sessions, including storing tokens and refreshing them when they expire."
sidebar:
  label: "Manage sessions"
prev:
  label: "Passwordless"
  link: "/guides/fsa/passwordless/"
next:
  label: "Logout"
  link: "/guides/fsa/logout/"
---
import { Steps, Tabs, TabItem, Aside, Card } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

Once a user successfully signs in, your application receives an `authResult` object containing tokens. This guide explains how to use these tokens to manage the user's session, keep them signed in, and handle token expiration.

<Aside type="note">
To receive a `refreshToken`, you must include `offline_access` in the `scopes` when generating the [authorization URL](/fsa/quickstart/#redirect-the-user-to-the-authentication-page). Refresh tokens allow you to obtain new access tokens without requiring the user to sign in again.
</Aside>

<Steps>
1. ## Store session tokens securely
   The `authResult` object contains an `accessToken`, `idToken`, and an optional `refreshToken`. These should be stored securely.

    - **accessToken**: A short-lived token used to access protected resources. Store it in a secure, HTTP-only cookie to prevent XSS attacks.
    - **refreshToken**: A long-lived token used to get a new `accessToken`. Store it securely in your backend, like a database, associated with the user's session.

    Here's how to set the `accessToken` as a cookie in an Express.js application:

    ```javascript title="Express.js"
    import cookieParser from 'cookie-parser';

    // Set cookie parser middleware in your app
    app.use(cookieParser());

    // After receiving the authResult from scalekit.authenticateWithCode()
    const { accessToken, expiresIn, refreshToken } = authResult;

    // Store the refreshToken securely in your database
    await db.saveRefreshToken(user.id, refreshToken);

    // Set the accessToken as a secure, HTTP-only cookie
    res.cookie('accessToken', accessToken, {
      maxAge: (expiresIn - 60) * 1000, // in milliseconds
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict'
    });
    ```

    <Card title="Session Security Configuration">
      You can configure session lifetimes, idle timeouts, and other security settings from the **[Session Configuration](https://app.scalekit.com/dashboard/auth/session)** section in your Scalekit dashboard.
    </Card>

2. ## Verify the access token

    Create a middleware to protect your application's routes. This middleware will check for a valid `accessToken` on every request.

    ```javascript title="middleware/auth.js"
    async function verifyToken(req, res, next) {
      const { accessToken } = req.cookies;

      if (!accessToken) {
        return res.status(401).send('Authentication required.');
      }

      try {
        // Use the Scalekit SDK to validate the token
        const { user } = await scalekit.validateAccessToken(accessToken);
        req.user = user; // Attach user info to the request
        next();
      } catch (error) {
        // This could mean the token is expired or invalid
        // Proceed to the refresh token logic
        return handleTokenRefresh(req, res, next);
      }
    }
    ```

3. ## Refresh the access token

    When an `accessToken` expires, use the `refreshToken` to get a new one without forcing the user to log in again. This logic can be integrated into your `verifyToken` middleware or called when an API call fails with a 401 error.

    ```javascript
    async function handleTokenRefresh(req, res, next) {
        // Retrieve the user's stored refresh token from your database
        const storedRefreshToken = await db.getRefreshToken(req.user.id);

        if (!storedRefreshToken) {
            return res.status(401).send('Authentication required.');
        }

        try {
            const authResult = await scalekit.refreshToken(storedRefreshToken);
            const { accessToken, expiresIn, refreshToken: newRefreshToken } = authResult;

            // 1. Update the refresh token in your database
            await db.saveRefreshToken(req.user.id, newRefreshToken);

            // 2. Update the accessToken cookie
            res.cookie('accessToken', accessToken, {
                maxAge: (expiresIn - 60) * 1000,
                httpOnly: true,
                secure: process.env.NODE_ENV === 'production',
                sameSite: 'strict'
            });

            // 3. Attach user info to the request and proceed
            req.user = authResult.user;
            next();

        } catch (error) {
            // If refresh fails, the user must re-authenticate
            // Clear cookies and session data
            return res.status(401).send('Session expired. Please log in again.');
        }
    }
    ```
    With this setup, your application can maintain user sessions securely, handle expirations gracefully, and provide a smooth user experience.
</Steps>
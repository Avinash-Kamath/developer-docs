---
title: "Manage user sessions"
description: "Learn how to manage user sessions, including storing tokens and refreshing them when they expire."
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
sidebar:
  label: "Handle user sessions"
prev:
  label: "Passwordless"
  link: "/guides/fsa/passwordless/"
next:
  label: "Logout"
  link: "/guides/fsa/logout/"
---
import { Steps, Tabs, TabItem, Aside, Card } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

Once a user [successfully signs in](/fsa/quickstart/#retrieve-user-profile-after-identity-verification), your application receives an response object containing session tokens. This guide explains how to use these tokens to manage the user's session, keep them signed in, and handle token expiration.

<Tabs syncKey="tech-stack">
  <TabItem value="node" label="Node.js">
  ```javascript title="Express.js"
  const authResult = await scalekit.authenticateWithCode(
    code, redirectUri
  );

  // authResult = {
  //   user: {
  //     email: "john.doe@example.com",
  //     emailVerified: true,
  //     givenName: "John",
  //     name: "John Doe",
  //     id: "usr_74599896446906854"
  //   },
  //   idToken: "eyJhbGciO..",
  //   accessToken: "eyJhbGciOi..",
  //   refreshToken: "rt_8f7d6e5c4b3a2d1e0f9g8h7i6j..",
  //   expiresIn: 299
  // }
  ```
  </TabItem>
  <TabItem value="py" label="Python">
  ```python
  auth_result = scalekit_client.authenticate_with_code(
    code=code,
    redirect_uri=redirect_uri
  )

  # auth_result = {
  #   user: {
  #     email: "john.doe@example.com",
  #     emailVerified: True,
  #     givenName: "John",
  #     name: "John Doe",
  #     id: "usr_74599896446906854"
  #   },
  #   idToken: "eyJhbGciO..",
  #   accessToken: "eyJhbGciOi..",
  #   refreshToken: "rt_8f7d6e5c4b3a2d1e0f9g8h7i6j..",
  #   expiresIn: 299
  # }
  ```
  </TabItem>
  <TabItem value="go" label="Go">
  ```go
  authResult, err := scalekitClient.AuthenticateWithCode(
    code,
    redirectUri,
  )
  if err != nil {
    // Handle error
  }

  // authResult = {
  //   user: {
  //     email: "john.doe@example.com",
  //     emailVerified: true,
  //     givenName: "John",
  //     name: "John Doe",
  //     id: "usr_74599896446906854"
  //   },
  //   idToken: "eyJhbGciO..",
  //   accessToken: "eyJhbGciOi..",
  //   refreshToken: "rt_8f7d6e5c4b3a2d1e0f9g8h7i6j..",
  //   expiresIn: 299
  // }
  ```
  </TabItem>
  <TabItem value="java" label="Java">
  ```java
  AuthResult authResult = scalekitClient.authentication().authenticateWithCode(
    code,
    redirectUri
  );

  // authResult = {
  //   user: {
  //     email: "john.doe@example.com",
  //     emailVerified: true,
  //     givenName: "John",
  //     name: "John Doe",
  //     id: "usr_74599896446906854"
  //   },
  //   idToken: "eyJhbGciO..",
  //   accessToken: "eyJhbGciOi..",
  //   refreshToken: "rt_8f7d6e5c4b3a2d1e0f9g8h7i6j..",
  //   expiresIn: 299
  // }
  ```
  </TabItem>
</Tabs>

<Steps>
1. ## Store session tokens securely
   The response object contains an `accessToken`, `idToken`, and an optional `refreshToken`. These should be stored securely.

    - **accessToken**: A short-lived token used to access protected resources. Store it in a secure, HTTP-only cookie to prevent XSS attacks.
    - **refreshToken**: A long-lived token used to get a new `accessToken`. Store it securely in your backend, like a database, associated with the user's session.

    Here's how to set the `accessToken` as a cookie in an Express.js application:

    ```javascript title="Express.js" wrap ins={7}
    import cookieParser from 'cookie-parser';

    // Set cookie parser middleware in your app
    app.use(cookieParser());

    // After receiving the authResult from scalekit.authenticateWithCode()
    const { accessToken, expiresIn, refreshToken } = authResult;

    // Store the refreshToken securely in your database or in memory
    await db.saveRefreshToken(user.id, refreshToken);

    // Set the accessToken as a secure, HTTP-only cookie
    res.cookie('accessToken', accessToken, {
      maxAge: (expiresIn - 60) * 1000, // in milliseconds
      httpOnly: true,
      secure: true,
      sameSite: 'strict'
    });
    ```

    You can configure session lifetimes, idle timeouts, and other security settings from the [Session Configuration](/reference/fsa/session-configs/) section in your Scalekit dashboard.

    <Aside type="note">
    To receive a `refreshToken`, you must include `offline_access` in the `scopes` when generating the [authorization URL](/fsa/quickstart/#redirect-the-user-to-the-authentication-page). Refresh tokens allow you to obtain new access tokens without requiring the user to sign in again.
    </Aside>

2. ## Verify the access token

    Create a middleware to protect your application's routes. This middleware will check for a valid `accessToken` on every request.

    ```javascript title="middleware/auth.js" wrap showLineNumbers=true ins={10}
    async function verifyToken(req, res, next) {
      const { accessToken } = req.cookies;

      if (!accessToken) {
        return res.status(401).send('Authentication required.');
      }

      try {
        // Use the Scalekit SDK to validate the token
        const { user } = await scalekit.validateAccessToken(accessToken);
        req.user = user; // Attach user info to the request
        next();
      } catch (error) {
        // This could mean the token is expired or invalid
        // Proceed to the refresh token logic
        return handleTokenRefresh(req, res, next);
      }
    }
    ```

3. ## Refresh the access token

    When an `accessToken` expires, use the `refreshToken` to get a new one without forcing the user to log in again. This logic can be integrated into your `verifyToken` middleware or called when an API call fails with a 401 error.

    ```javascript wrap showLineNumbers=true ins={10}
    async function handleTokenRefresh(req, res, next) {
      // Retrieve the user's stored refresh token from your database
      const storedRefreshToken = await db.getRefreshToken(req.user.id);

      if (!storedRefreshToken) {
        return res.status(401).send('Authentication required.');
      }

      try {
        const authResult = await scalekit.refreshToken(storedRefreshToken);
        const { accessToken, expiresIn, refreshToken: newRefreshToken } = authResult;

        // 1. Update the refresh token in your database
        await db.saveRefreshToken(req.user.id, newRefreshToken);

        // 2. Update the accessToken cookie
        res.cookie('accessToken', accessToken, {
          maxAge: (expiresIn - 60) * 1000,
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict'
        });

        // 3. Attach user info to the request and proceed
        req.user = authResult.user;
        next();

      } catch (error) {
        // If refresh fails, the user must re-authenticate
        // Clear cookies and session data
        return res.status(401).send('Session expired. Please log in again.');
      }
    }
    ```
    With this setup, your application can maintain user sessions securely, handle expirations gracefully, and provide a smooth user experience.
</Steps>